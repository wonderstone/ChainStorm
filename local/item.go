package local

import (
	"fmt"
	"sync"

	"github.com/emirpasic/gods/maps/hashbidimap"
)

// ~ GraphDB Definition Section

// Node is equal to Vertex
// ID, Collection,Name are mandatory
// ID is the unique identifier of the node
// Collection is the category of the node, like "person", "company", "product"
// Name is the name of the node
// Data is a map[string]interface{}, and key should be unique with timestamp suffix
// also give the json tag to the struct field

type Node struct {
	ID         string                 `json:"ID"`         // 节点的唯一标识符
	Collection string                 `json:"Collection"` // 节点所属的集合
	Name       string                 `json:"Name"`       // 节点的名称
	Data       map[string]interface{} `json:"Data"`       // 节点存储的数据
}

type NOption func(*Node)

func WithNID(id string) NOption {
	return func(n *Node) {
		n.ID = id
	}
}

func WithNCollection(collection string) NOption {
	return func(n *Node) {
		n.Collection = collection
	}
}

func WithNName(name string) NOption {
	return func(n *Node) {
		n.Name = name
	}
}

func WithNData(data map[string]interface{}) NOption {
	return func(n *Node) {
		n.Data = data
	}
}

// NewNode 用于创建一个新的节点, if node mandatory info is not provided, it will return nil and error
// 
func NewNode(options ...NOption) (*Node,error) {
	n := &Node{
		Data:       make(map[string]interface{}),
	}
	for _, opt := range options {
		opt(n)
	}
	// check if node contains the ID, if not, return nil and error
	if n.ID == "" {
		return nil,fmt.Errorf("ID is mandatory")
	}
	// check if node contains the Collection, if not, return nil and error
	if n.Collection == "" {
		return nil,fmt.Errorf("Collection is mandatory")
	}
	// check if node contains the Name, if not, return nil and error
	if n.Name == "" {
		return nil,fmt.Errorf("Name is mandatory")
	}

	return n,nil
}

// Export 用于导出节点的数据 in json format
func (n *Node) Export() map[string]interface{} {
	tmp := n.Data
	tmp["ID"] = n.ID
	tmp["Collection"] = n.Collection
	tmp["Name"] = n.Name
	return tmp
}


// Edge 代表两个节点之间的连接（边）, collection, from, to and Data are mandatory
// Edge 不能脱离节点而存在 所以单独NewEdge时，需要传入from和to
// 在其上层的图结构中，先有NewNode，再有NewEdge是合理的
// if Data contains the ID, then ID is the value
// if Data doesn't contain the ID, then ID is generated by the uuid package
// if Data contains the Weight, then Weight is the value
// if Data doesn't contain the Weight, then Weight is 0
type Edge struct {
	ID         string                 // 边的唯一标识符
	Collection string                 // 边所属的集合
	Name	   string                 // 边的名称
	From       *Node                  // 起始节点
	To         *Node                  // 目标节点
	Weight     int                    // 边的权重
	Data       map[string]interface{} // 节点存储的数据
}

// EdgeJSON is an intermediate struct for JSON deserialization
type EdgeJSON struct {
    ID         string                 `json:"ID"`
    Collection string                 `json:"Collection"`
	Name 	   string                 `json:"Name"`
    From       string                 `json:"From"`
    To         string                 `json:"To"`
    Weight     int                    `json:"Weight"`
    Data       map[string]interface{} `json:"Data"`
}

type EOption func(*Edge)

func WithEID(id string) EOption {
	return func(e *Edge) {
		e.ID = id
	}
}

func WithECollection(collection string) EOption {
	return func(e *Edge) {
		e.Collection = collection
	}

}

func WithEName(name string) EOption {
	return func(e *Edge) {
		e.Name = name
	}
}


func WithEFrom(from *Node) EOption {
	return func(e *Edge) {
		e.From = from
	}
}

func WithETo(to *Node) EOption {
	return func(e *Edge) {
		e.To = to
	}
}

func WithEWeight(weight int) EOption {
	return func(e *Edge) {
		e.Weight = weight
	}
}

func WithEData(data map[string]interface{}) EOption {
	return func(e *Edge) {
		e.Data = data
	}
}

// NewEdge 用于创建一个新的边, collection, from, to are mandatory
func NewEdge(options ...EOption) (*Edge,error) {
	e := &Edge{
		Weight:     1,
		Data:       make(map[string]interface{}),
	}
	for _, opt := range options {
		opt(e)
	}
	// check if edge contains the ID,  if not, return nil and error
	if e.ID == "" {
		return nil,fmt.Errorf("ID is mandatory")
	}

	// check if edge contains the Collection,  if not, return nil and error
	if e.Collection == "" {
		return nil,fmt.Errorf("Collection is mandatory")
	}

	// check if edge contains the Name,  if not, return nil and error
	if e.Name == "" {
		return nil,fmt.Errorf("Name is mandatory")
	}


	// check if edge contains the From,  if not, return nil and error
	if e.From == nil {
		return nil,fmt.Errorf("From is mandatory")
	}

	// check if edge contains the To,  if not, return nil and error
	if e.To == nil {
		return nil,fmt.Errorf("To is mandatory")
	}

	return e,nil
}

func (e *Edge) Export() map[string]interface{} {
	tmp := e.Data
	tmp["ID"] = e.ID
	tmp["Collection"] = e.Collection
	tmp["Name"] = e.Name
	tmp["From"] = e.From.ID
	tmp["To"] = e.To.ID
	tmp["Weight"] = e.Weight
	return tmp
}

func (e *Edge) ExportJSON() *EdgeJSON {
	return &EdgeJSON{
		ID:         e.ID,
		Collection: e.Collection,
		Name:       e.Name,
		From:       e.From.ID,
		To:         e.To.ID,
		Weight:     e.Weight,
		Data:       e.Data,
	}
}


func (ej *EdgeJSON) Export() map[string]interface{} {
	tmp := ej.Data
	tmp["ID"] = ej.ID
	tmp["Collection"] = ej.Collection
	tmp["From"] = ej.From
	tmp["To"] = ej.To
	tmp["Weight"] = ej.Weight
	return tmp
}

// InMemoryDB 代表整个图结构
type InMemoryDB struct {
	Nodes map[string]*Node // 节点集合, key is the ID of the node
	Edges map[string]*Edge // 边集合, key is the ID of the edge

	m          sync.RWMutex // 用于并发控制的读写锁
	configPath string       // 配置文件路径

	// BidiMap for ID : NodeName and ID : EdgeName
	NodeNameMap *hashbidimap.Map
	EdgeNameMap *hashbidimap.Map

}

func NewInMemoryDB() *InMemoryDB {
	return &InMemoryDB{
		Nodes: make(map[string]*Node),
		Edges: make(map[string]*Edge),
		NodeNameMap: hashbidimap.New(),
		EdgeNameMap: hashbidimap.New(),
	}
}

// ~ GraphDB Definition Section END
