package local

import (
	"fmt"
	"sync"

	"github.com/emirpasic/gods/maps/hashbidimap"

	"encoding/json"
	"io"
	"os"
	"path/filepath"
)

type void struct{}

// ~ GraphDB Definition Section

// Node is equal to Vertex
// ID, Collection,Name are mandatory
// ID is the unique identifier of the node
// Collection is the category of the node, like "person", "company", "product"
// Name is the name of the node
// Data is a map[string]interface{}, and key should be unique with timestamp suffix
// also give the json tag to the struct field

type Node struct {
	ID         string                 `json:"ID"`         // 节点的唯一标识符
	Collection string                 `json:"Collection"` // 节点所属的集合
	Name       string                 `json:"Name"`       // 节点的名称
	Data       map[string]interface{} `json:"Data"`       // 节点存储的数据
}

type NOption func(*Node)

func WithNID(id string) NOption {
	return func(n *Node) {
		n.ID = id
	}
}

func WithNCollection(collection string) NOption {
	return func(n *Node) {
		n.Collection = collection
	}
}

func WithNName(name string) NOption {
	return func(n *Node) {
		n.Name = name
	}
}

func WithNData(data map[string]interface{}) NOption {
	return func(n *Node) {
		n.Data = data
	}
}

// NewNode 用于创建一个新的节点, if node mandatory info is not provided, it will return nil and error
func NewNode(options ...NOption) (*Node, error) {
	n := &Node{
		Data: make(map[string]interface{}),
	}
	for _, opt := range options {
		opt(n)
	}
	// check if node contains the ID, if not, return nil and error
	if n.ID == "" {
		return nil, fmt.Errorf("ID is mandatory")
	}
	// check if node contains the Collection, if not, return nil and error
	if n.Collection == "" {
		return nil, fmt.Errorf("collection is mandatory")
	}
	// check if node contains the Name, if not, return nil and error
	if n.Name == "" {
		return nil, fmt.Errorf("name is mandatory")
	}

	return n, nil
}

// Export 用于导出节点的数据 in json format
func (n *Node) Export() map[string]interface{} {
	tmp := n.Data
	tmp["ID"] = n.ID
	tmp["Collection"] = n.Collection
	tmp["Name"] = n.Name
	return tmp
}

// Edge 代表两个节点之间的连接（边）, collection, from, to and Data are mandatory
// Edge 不能脱离节点而存在 所以单独NewEdge时，需要传入from和to
// 在其上层的图结构中，先有NewNode，再有NewEdge是合理的
// if Data contains the ID, then ID is the value
// if Data doesn't contain the ID, then ID is generated by the uuid package
// if Data contains the Weight, then Weight is the value
// if Data doesn't contain the Weight, then Weight is 0
type Edge struct {
	ID         string                 // 边的唯一标识符
	Collection string                 // 边所属的集合
	Name       string                 // 边的名称
	From       *Node                  // 起始节点
	To         *Node                  // 目标节点
	Weight     int                    // 边的权重
	Data       map[string]interface{} // 节点存储的数据
}

// EdgeJSON is an intermediate struct for JSON deserialization
type EdgeJSON struct {
	ID         string                 `json:"ID"`
	Collection string                 `json:"Collection"`
	Name       string                 `json:"Name"`
	From       string                 `json:"From"`
	To         string                 `json:"To"`
	Weight     int                    `json:"Weight"`
	Data       map[string]interface{} `json:"Data"`
}

type EOption func(*Edge)

func WithEID(id string) EOption {
	return func(e *Edge) {
		e.ID = id
	}
}

func WithECollection(collection string) EOption {
	return func(e *Edge) {
		e.Collection = collection
	}

}

func WithEName(name string) EOption {
	return func(e *Edge) {
		e.Name = name
	}
}

func WithEFrom(from *Node) EOption {
	return func(e *Edge) {
		e.From = from
	}
}

func WithETo(to *Node) EOption {
	return func(e *Edge) {
		e.To = to
	}
}

func WithEWeight(weight int) EOption {
	return func(e *Edge) {
		e.Weight = weight
	}
}

func WithEData(data map[string]interface{}) EOption {
	return func(e *Edge) {
		e.Data = data
	}
}

// NewEdge 用于创建一个新的边, collection, from, to are mandatory
func NewEdge(options ...EOption) (*Edge, error) {
	e := &Edge{
		Weight: 1,
		Data:   make(map[string]interface{}),
	}
	for _, opt := range options {
		opt(e)
	}
	// check if edge contains the ID,  if not, return nil and error
	if e.ID == "" {
		return nil, fmt.Errorf("ID is mandatory")
	}

	// check if edge contains the Collection,  if not, return nil and error
	if e.Collection == "" {
		return nil, fmt.Errorf("collection is mandatory")
	}

	// check if edge contains the Name,  if not, return nil and error
	if e.Name == "" {
		return nil, fmt.Errorf("name is mandatory")
	}

	// check if edge contains the From,  if not, return nil and error
	if e.From == nil {
		return nil, fmt.Errorf("from is mandatory")
	}

	// check if edge contains the To,  if not, return nil and error
	if e.To == nil {
		return nil, fmt.Errorf("to is mandatory")
	}

	return e, nil
}

func (e *Edge) Export() map[string]interface{} {
	tmp := e.Data
	tmp["ID"] = e.ID
	tmp["Collection"] = e.Collection
	tmp["Name"] = e.Name
	tmp["From"] = e.From.ID
	tmp["To"] = e.To.ID
	tmp["Weight"] = e.Weight
	return tmp
}

func (e *Edge) ExportJSON() *EdgeJSON {
	return &EdgeJSON{
		ID:         e.ID,
		Collection: e.Collection,
		Name:       e.Name,
		From:       e.From.ID,
		To:         e.To.ID,
		Weight:     e.Weight,
		Data:       e.Data,
	}
}

func (ej *EdgeJSON) Export() map[string]interface{} {
	tmp := ej.Data
	tmp["ID"] = ej.ID
	tmp["Collection"] = ej.Collection
	tmp["From"] = ej.From
	tmp["To"] = ej.To
	tmp["Weight"] = ej.Weight
	return tmp
}

// ReadJSONFile reads a JSON file and returns its contents as a map
func ReadJSONFile(filePath string) (map[string]interface{}, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	byteValue, err := io.ReadAll(file)
	if err != nil {
		return nil, err
	}

	var result map[string]interface{}
	err = json.Unmarshal(byteValue, &result)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func WriteJSONFile(filePath string, data interface{}) error {
	// check the filePath dir is exist. if not, create dir
	dir := filepath.Dir(filePath)
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}
	// Open the file for writing, create it if it doesn't exist
	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	// Encode the data to JSON and write it to the file
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ") // Optional: for pretty-printing
	if err := encoder.Encode(data); err != nil {
		return err
	}

	return nil
}

// InMemoryDB 代表整个图结构
type InMemoryDB struct {
	Nodes map[string]*Node // 节点集合, key is the ID of the node
	Edges map[string]*Edge // 边集合, key is the ID of the edge

	m           sync.RWMutex    // 用于并发控制的读写锁
	configPath  string          // 配置文件路径
	nodeNameSet map[string]void // 用于存储节点名称的集合 要建立node name的唯一性约束
	edgeNameSet map[string]void // 用于存储边名称的集合 要建立edge name的唯一性约束

	// BidiMap for ID : NodeName and ID : EdgeName
	NodeNameMap *hashbidimap.Map
	EdgeNameMap *hashbidimap.Map
}

func NewInMemoryDB() (*InMemoryDB, error) {
	db := &InMemoryDB{
		Nodes: make(map[string]*Node),
		Edges: make(map[string]*Edge),

		nodeNameSet: make(map[string]void),
		edgeNameSet: make(map[string]void),

		NodeNameMap: hashbidimap.New(),
		EdgeNameMap: hashbidimap.New(),
	}

	// Check if any of the initializations failed
	if db.Nodes == nil || db.Edges == nil || db.nodeNameSet == nil || db.edgeNameSet == nil || db.NodeNameMap == nil || db.EdgeNameMap == nil {
		return nil, fmt.Errorf("failed to initialize InMemoryDB")
	}

	return db, nil
}

// Export 用于导出NodeNameMap 和 EdgeNameMap 的数据 in json format
func (db *InMemoryDB) Export() map[string]interface{} {
	tmp := make(map[string]interface{})
	// iter all the nodes in the NodeNameMap and output the key and data pair in json
	nodeNameMap := make(map[string]string)
	for _, k := range db.NodeNameMap.Keys() {
		v, _ := db.NodeNameMap.Get(k)
		nodeNameMap[k.(string)] = v.(string)
	}
	tmp["NodeNameMap"] = nodeNameMap

	// iter all the edges in the EdgeNameMap and output the key and data pair in json
	edgeNameMap := make(map[string]string)
	for _, k := range db.EdgeNameMap.Keys() {
		v, _ := db.EdgeNameMap.Get(k)
		edgeNameMap[k.(string)] = v.(string)
	}

	tmp["EdgeNameMap"] = edgeNameMap

	return tmp
}

// Import 用于导入NodeNameMap 和 EdgeNameMap 的数据 in json format
func (db *InMemoryDB) Import(data map[string]interface{}) error {

	// check if the data contains the NodeNameMap key
	if _, ok := data["NodeNameMap"]; !ok {
		return fmt.Errorf("NodeNameMap is missing")
	}

	// check if the data contains the EdgeNameMap key
	if _, ok := data["EdgeNameMap"]; !ok {
		return fmt.Errorf("EdgeNameMap is missing")
	}

	// import the NodeNameMap data
	nodeNameMap, ok := data["NodeNameMap"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("NodeNameMap is not a map")
	}

	for k, v := range nodeNameMap {
		db.NodeNameMap.Put(k, v)
	}

	// import the EdgeNameMap data
	edgeNameMap, ok := data["EdgeNameMap"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("EdgeNameMap is not a map")
	}
	for k, v := range edgeNameMap {
		db.EdgeNameMap.Put(k, v)
	}

	return nil

}

// RegenerateSet iterates through all nodes and edges in the database,
// updating the nodeNameSet and edgeNameSet to ensure that each node
// and edge name is unique. If a duplicate name is found, an error is returned.
func (db *InMemoryDB) RegenerateSet() error {
	db.nodeNameSet = make(map[string]void)
	db.edgeNameSet = make(map[string]void)
	// Iterate over all nodes in the database to update the node name set.
	// This ensures that each node name is unique by checking for duplicates.
	for _, v := range db.Nodes {
		// Check if the node name is already in the set.
		// This ensures that each node name is unique within the graph.
		// If the node name is found in the set, return an error indicating the name is not unique.
		if _, ok := db.nodeNameSet[v.Name]; ok {
			return fmt.Errorf("node name %s is not unique", v.Name)
		}
		db.nodeNameSet[v.Name] = void{}
	}
	// Check if the edge name is already in the set.
	// This ensures that each edge name is unique within the graph.
	// If a duplicate edge name is found, return an error indicating the name is not unique.
	for _, v := range db.Edges {
		// if the edge name is already in the set, then return an error
		if _, ok := db.edgeNameSet[v.Name]; ok {
			return fmt.Errorf("edge name %s is not unique", v.Name)
		}
		db.edgeNameSet[v.Name] = void{}
	}
	return nil
}

// check if the node name is Exists
func (db *InMemoryDB) checkNodeNameExists(name string) bool {
	_, ok := db.nodeNameSet[name]
	return ok
}

// check if the edge name is Exists
func (db *InMemoryDB) checkEdgeNameExists(name string) bool {
	_, ok := db.edgeNameSet[name]
	return ok
}

// update the two NodeNameMap and EdgeNameMap bidimap by the Nodes and Edges
func (db *InMemoryDB) RegenerateBidimap() {
	db.NodeNameMap.Clear()
	db.EdgeNameMap.Clear()
	// iter all the nodes and edges and update the two bidimap
	for k, v := range db.Nodes {
		db.NodeNameMap.Put(k, v.Name)
	}

	for k, v := range db.Edges {
		db.EdgeNameMap.Put(k, v.Name)
	}
}

// ~ GraphDB Definition Section END
