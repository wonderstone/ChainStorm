package local

import (
	"sync"

	"github.com/google/uuid"
)


// ~ GraphDB Definition Section 

// Node 代表图中的一个节点, equal to Vertex
// add ID and Collection to Node, to make it more easy to manage
// concept borrowed from arangodb
type Node struct {
	ID         string                 // 节点的唯一标识符
	Collection string                 // 节点所属的集合
	Data       map[string]interface{} // 节点存储的数据
}

type NOption func(*Node)

func WithNID(id string) NOption {
	return func(n *Node) {
		n.ID = id
	}
}

func WithNCollection(collection string) NOption {
	return func(n *Node) {
		n.Collection = collection
	}
}

func WithNData(data map[string]interface{}) NOption {
	return func(n *Node) {
		n.Data = data
	}
}

// NewNode 用于创建一个新的节点, collection and data are mandatory
// collection is the category of the node, like "person", "company", "product"
// ID is the unique identifier of the node, if Data contains the ID, then ID is the value
// the original Data should not have ID or Collection, but exported Data will have ID and Collection
// Data is a map[string]interface{}, and key should be unique with timestamp suffix
// if Data doesn't contain the ID, then ID is generated by the uuid package
func NewNode(options ...NOption) *Node {
	n := &Node{
		Collection: "Default",
		Data:       make(map[string]interface{}),
	}
	for _, opt := range options {
		opt(n)
	}
	// check if data contains the ID
	if _, ok := n.Data["ID"]; !ok {
		// check if the ID is provided
		if n.ID == "" {
			// generate the ID
			n.ID = uuid.New().String()
		}
	} else {
		n.ID = n.Data["ID"].(string)
		delete(n.Data, "ID")
	}
	// check if data contains the Collection
	if _, ok := n.Data["Collection"]; ok {
		n.Collection = n.Data["Collection"].(string)
		delete(n.Data, "Collection")
	}
	return n
}

func (n *Node) Export() map[string]interface{} {
	tmp := n.Data
	tmp["ID"] = n.ID
	tmp["Collection"] = n.Collection
	return tmp
}

// Edge 代表两个节点之间的连接（边）, collection, from, to and Data are mandatory
// Edge 不能脱离节点而存在 所以单独NewEdge时，需要传入from和to
// 在其上层的图结构中，先有NewNode，再有NewEdge是合理的
// if Data contains the ID, then ID is the value
// if Data doesn't contain the ID, then ID is generated by the uuid package
// if Data contains the Weight, then Weight is the value
// if Data doesn't contain the Weight, then Weight is 0
type Edge struct {
	ID         string                 // 边的唯一标识符
	Collection string                 // 边所属的集合
	From       *Node                  // 起始节点
	To         *Node                  // 目标节点
	Weight     int                    // 边的权重
	Data       map[string]interface{} // 节点存储的数据
}

type EOption func(*Edge)

func WithEID(id string) EOption {
	return func(e *Edge) {
		e.ID = id
	}
}

func WithECollection(collection string) EOption {
	return func(e *Edge) {
		e.Collection = collection
	}

}

func WithEFrom(from *Node) EOption {
	return func(e *Edge) {
		e.From = from
	}
}

func WithETo(to *Node) EOption {
	return func(e *Edge) {
		e.To = to
	}
}

func WithEWeight(weight int) EOption {
	return func(e *Edge) {
		e.Weight = weight
	}
}

func WithEData(data map[string]interface{}) EOption {
	return func(e *Edge) {
		e.Data = data
	}
}

// NewEdge 用于创建一个新的边, collection, from, to and data are mandatory
func NewEdge(options ...EOption) *Edge {
	e := &Edge{
		Collection: "Default",
		Weight:     0,
		Data:       make(map[string]interface{}),
	}
	for _, opt := range options {
		opt(e)
	}
	// check if data contains the ID
	if _, ok := e.Data["ID"]; !ok {
		// check if the ID is provided
		if e.ID == "" {
			// generate the ID
			e.ID = uuid.New().String()
		}
	} else {
		e.ID = e.Data["ID"].(string)
		delete(e.Data, "ID")
	}
	// check if data contains the Collection
	if _, ok := e.Data["Collection"]; ok {
		e.Collection = e.Data["Collection"].(string)
		delete(e.Data, "Collection")
	}

	return e
}

func (e *Edge) Export() map[string]interface{} {
	tmp := e.Data
	tmp["ID"] = e.ID
	tmp["Collection"] = e.Collection
	tmp["From"] = e.From.ID
	tmp["To"] = e.To.ID
	tmp["Weight"] = e.Weight
	return tmp
}

// InMemoryDB 代表整个图结构
type InMemoryDB struct {
	Nodes map[string]*Node // 节点集合, key is the ID of the node
	Edges map[string]*Edge // 边集合, key is the ID of the edge

	m          sync.RWMutex // 用于并发控制的读写锁
	configPath string       // 配置文件路径
}

func NewInMemoryDB() *InMemoryDB {
	return &InMemoryDB{
		Nodes: make(map[string]*Node),
		Edges: make(map[string]*Edge),
	}
}

// ~ GraphDB Definition Section END

