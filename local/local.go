package local

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"sync"

	"github.com/google/uuid"
	"gopkg.in/yaml.v3"
)

// Add Timestamp to the key
func AddTimestampToKey(key, timeStamp string) string {
	return key + "_" + timeStamp
}

// merge two map[string]interface{} into one
// if the key is the same, the value in the second map will overwrite the value in the first map
func MergeMaps(m1, m2 map[string]interface{}) map[string]interface{} {
	m := make(map[string]interface{})
	for k, v := range m1 {
		m[k] = v
	}
	for k, v := range m2 {
		m[k] = v
	}
	return m
}

// recoverFromPanic handles panic recovery and sets the error
func recoverFromPanic(err *error) {
	if r := recover(); r != nil {
		if errVal, ok := r.(error); ok {
			*err = errVal
		} else {
			*err = fmt.Errorf("unexpected panic: %v", r)
		}
	}
}

func ReadJSONFile(filePath string) (map[string]interface{}, error) {
	// read the JSON file
	jsonData, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}
	// unmarshal the JSON data into a map
	var data map[string]interface{}
	err = json.Unmarshal(jsonData, &data)
	if err != nil {
		return nil, err
	}
	return data, nil
}

func WriteJSONFile(filePath string, data map[string]interface{}) error {
	// marshal the data into JSON
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}
	// write the JSON data to the file
	err = os.WriteFile(filePath, jsonData, 0644)
	if err != nil {
		return err
	}
	return nil
}

// Node 代表图中的一个节点, equal to Vertex
// add ID and Collection to Node, to make it more easy to manage
// concept borrowed from arangodb
type Node struct {
	ID         string                 // 节点的唯一标识符
	Collection string                 // 节点所属的集合
	Data       map[string]interface{} // 节点存储的数据
}

type NOption func(*Node)

func WithNID(id string) NOption {
	return func(n *Node) {
		n.ID = id
	}
}

func WithNCollection(collection string) NOption {
	return func(n *Node) {
		n.Collection = collection
	}
}

func WithNData(data map[string]interface{}) NOption {
	return func(n *Node) {
		n.Data = data
	}
}


// NewNode 用于创建一个新的节点, collection and data are mandatory
// collection is the category of the node, like "person", "company", "product"
// ID is the unique identifier of the node, if Data contains the ID, then ID is the value
// the original Data should not have ID or Collection, but exported Data will have ID and Collection
// Data is a map[string]interface{}, and key should be unique with timestamp suffix
// if Data doesn't contain the ID, then ID is generated by the uuid package
func NewNode(options ... NOption) *Node {
	n := &Node{
		Collection: "Default",
		Data: make(map[string]interface{}),
	}
	for _, opt := range options {
		opt(n)
	}
	// check if data contains the ID
	if _, ok := n.Data["ID"]; !ok {
		// check if the ID is provided
		if n.ID == "" {
			// generate the ID
			n.ID = uuid.New().String()
		}
	} else {
		n.ID = n.Data["ID"].(string)
		delete(n.Data, "ID")
	}
	// check if data contains the Collection
	if _, ok := n.Data["Collection"]; ok {
		n.Collection = n.Data["Collection"].(string)
		delete(n.Data, "Collection")
	}
	return n
}

func (n *Node) Export() map[string]interface{} {
	tmp := n.Data
	tmp["ID"] = n.ID
	tmp["Collection"] = n.Collection
	return tmp
}
// Edge 代表两个节点之间的连接（边）, collection, from, to and Data are mandatory
// if Data contains the ID, then ID is the value
// if Data doesn't contain the ID, then ID is generated by the uuid package
// if Data contains the Weight, then Weight is the value
// if Data doesn't contain the Weight, then Weight is 0
type Edge struct {
	ID         string                 // 边的唯一标识符
	Collection string                 // 边所属的集合
	From       *Node                  // 起始节点
	To         *Node                  // 目标节点
	Weight     int                    // 边的权重
	Data       map[string]interface{} // 节点存储的数据
}

// NewEdge 用于创建一个新的边, collection, from, to and data are mandatory
func NewEdge(Collection string, From, To *Node, Data map[string]interface{}) *Edge {
	// check if data contains the ID
	if _, ok := Data["ID"]; !ok {
		// generate the ID
		Data["ID"] = uuid.New().String()
	}
	// check if data contains the Weight
	if _, ok := Data["Weight"]; !ok {
		// set the Weight to 0
		Data["Weight"] = 0
	}
	return &Edge{
		ID:         Data["ID"].(string),
		Collection: Collection,
		From:       From,
		To:         To,
		Weight:     Data["Weight"].(int),
		Data:       Data,
	}
}

// InMemoryDB 代表整个图结构
type InMemoryDB struct {
	Nodes      map[string]*Node // 节点集合, key is the ID of the node
	Edges      map[string]*Edge // 边集合, key is the ID of the edge
	
	m          sync.RWMutex     // 用于并发控制的读写锁
	configPath string           // 配置文件路径
}

func NewInMemoryDB() *InMemoryDB {
	return &InMemoryDB{
		Nodes: make(map[string]*Node),
		Edges: make(map[string]*Edge),
	}
}

// Init 用于初始化图数据库
func (db *InMemoryDB) Init(yamlPath string) error {
	// read the config yaml file from the yamlPath
	// parse the yaml file and set the
	// db.configPath is equal to dataPath field in the yaml file
	// read the yaml file
	yamlData, err := os.ReadFile(yamlPath)

	if err != nil {
		return err
	}

	// unmarshal the yaml data into a map
	var data map[string]interface{}
	err = yaml.Unmarshal(yamlData, &data)

	if err != nil {
		return err
	}

	// set the db.configPath
	db.configPath = data["dataPath"].(string)
	return nil
}

// implement GraphDB interface, where collection is just a field in Node Data
func (db *InMemoryDB) AddVertex(collection string, data map[string]interface{}) (id string, err error) {
	db.m.Lock()
	defer db.m.Unlock()
	defer recoverFromPanic(&err)
	
	n := NewNode(WithNCollection(collection), WithNData(data))
	// check if the ID is already in the Nodes
	// if yes, merge the data
	// if no , add the node to the Nodes
	if _, ok := db.Nodes[n.ID]; !ok {
		db.Nodes[n.ID] = n
	} else {
		db.Nodes[n.ID].Collection = n.Collection
		db.Nodes[n.ID].Data = MergeMaps(db.Nodes[n.ID].Data, n.Data)

	}

	return n.ID, err
}

func (db *InMemoryDB) AddEdge(collection string, from, to string, data map[string]interface{}) (id string, err error) {
	db.m.Lock()
	defer db.m.Unlock()
	defer recoverFromPanic(&err)

	// ~ check if the from and to nodes exist
	if _, ok := db.Nodes[from]; !ok {
		return "", fmt.Errorf("node with ID %s does not exist", from)
	}
	if _, ok := db.Nodes[to]; !ok {
		return "", fmt.Errorf("node with ID %s does not exist", to)
	}

	e := NewEdge(collection, db.Nodes[from], db.Nodes[to], data)
	db.Edges[e.ID] = e

	return e.ID, err
}

func (db *InMemoryDB) GetVertexDB(id string) (map[string]interface{}, error) {
	db.m.RLock()
	defer db.m.RUnlock()
	// add ID and Collection to the return value

	if n, ok := db.Nodes[id]; ok {
		n.Data["ID"] = n.ID
		n.Data["Collection"] = n.Collection
		return n.Data, nil
	}
	return nil, fmt.Errorf("node with ID %s does not exist", id)
}

func (db *InMemoryDB) GetEdgeDB(id string) (map[string]interface{}, error) {
	db.m.RLock()
	defer db.m.RUnlock()
	// add ID , Collection , from , to  and weight to the return value
	if e, ok := db.Edges[id]; ok {
		e.Data["ID"] = e.ID
		e.Data["Collection"] = e.Collection
		e.Data["From"] = e.From.ID
		e.Data["To"] = e.To.ID
		e.Data["Weight"] = e.Weight
		return e.Data, nil
	}
	return nil, fmt.Errorf("edge with ID %s does not exist", id)
}

func (db *InMemoryDB) GetFromVertices(id string) ([]string, error) {
	db.m.RLock()
	defer db.m.RUnlock()

	if _, ok := db.Nodes[id]; !ok {
		return nil, fmt.Errorf("node with ID %s does not exist", id)
	}

	var fromVertices []string
	for _, e := range db.Edges {
		if e.To.ID == id {
			fromVertices = append(fromVertices, e.From.ID)
		}
	}

	return fromVertices, nil
}

func (db *InMemoryDB) GetToVertices(id string) ([]string, error) {
	db.m.RLock()
	defer db.m.RUnlock()

	if _, ok := db.Nodes[id]; !ok {
		return nil, fmt.Errorf("node with ID %s does not exist", id)
	}

	var toVertices []string
	for _, e := range db.Edges {
		if e.From.ID == id {
			toVertices = append(toVertices, e.To.ID)
		}
	}

	return toVertices, nil
}

func (db *InMemoryDB) GetInEdges(id string) ([]string, error) {
	db.m.RLock()
	defer db.m.RUnlock()

	if _, ok := db.Nodes[id]; !ok {
		return nil, fmt.Errorf("node with ID %s does not exist", id)
	}

	var inEdges []string
	for _, e := range db.Edges {
		if e.To.ID == id {
			inEdges = append(inEdges, e.ID)
		}
	}

	return inEdges, nil
}

func (db *InMemoryDB) GetOutEdges(id string) ([]string, error) {
	db.m.RLock()
	defer db.m.RUnlock()

	if _, ok := db.Nodes[id]; !ok {
		return nil, fmt.Errorf("node with ID %s does not exist", id)
	}

	var outEdges []string
	for _, e := range db.Edges {
		if e.From.ID == id {
			outEdges = append(outEdges, e.ID)
		}
	}

	return outEdges, nil
}

func (db *InMemoryDB) UpdateVertex(id string, data map[string]interface{}) error {
	db.m.Lock()
	defer db.m.Unlock()

	if _, ok := db.Nodes[id]; !ok {
		return fmt.Errorf("node with ID %s does not exist", id)
	}

	db.Nodes[id].Data = data

	return nil
}

func (db *InMemoryDB) UpdateEdge(id, from, to string, data map[string]interface{}) error {
	db.m.Lock()
	defer db.m.Unlock()

	if _, ok := db.Edges[id]; !ok {
		return fmt.Errorf("edge with ID %s does not exist", id)
	}

	if _, ok := db.Nodes[from]; !ok {
		return fmt.Errorf("node with ID %s does not exist", from)
	}

	if _, ok := db.Nodes[to]; !ok {
		return fmt.Errorf("node with ID %s does not exist", to)
	}

	db.Edges[id].From = db.Nodes[from]
	db.Edges[id].To = db.Nodes[to]
	db.Edges[id].Data = data

	return nil
}

func (db *InMemoryDB) DeleteVertex(id string) error {
	db.m.Lock()
	defer db.m.Unlock()

	if _, ok := db.Nodes[id]; !ok {
		return fmt.Errorf("node with ID %s does not exist", id)
	}

	delete(db.Nodes, id)

	// delete all edges connected to the node
	for tmpEdgeID, tmpEdge := range db.Edges {
		if tmpEdge.From.ID == id || tmpEdge.To.ID == id {
			delete(db.Edges, tmpEdgeID)
		}
	}

	return nil
}

func (db *InMemoryDB) DeleteEdge(id string) error {
	db.m.Lock()
	defer db.m.Unlock()

	if _, ok := db.Edges[id]; !ok {
		return fmt.Errorf("edge with ID %s does not exist", id)
	}

	delete(db.Edges, id)

	return nil
}


// GetVerticesByName use regular expression to get the vertices contain the name
func (db *InMemoryDB) GetVerticesByInfo(info string) ([]string, error) {
	db.m.RLock()
	defer db.m.RUnlock()

	var vertices []string
	for _, n := range db.Nodes {
		for _, v := range n.Data {
			IfContains, err := CheckContains(v.(string), info)
			if err != nil {
				return nil, err
			}
			if IfContains {
				vertices = append(vertices, n.ID)
				break
			}
		}
	}
	return vertices, nil
}

// GetEdgesByInfo use regular expression to get the edges contain the name
func (db *InMemoryDB) GetEdgesByInfo(info string) ([]string, error) {
	db.m.RLock()
	defer db.m.RUnlock()

	var edges []string
	for _, e := range db.Edges {
		for _, v := range e.Data {
			IfContains, err := CheckContains(v.(string), info)
			if err != nil {
				return nil, err
			}
			if IfContains {
				edges = append(edges, e.ID)
				break
			}
		}
	}
	return edges, nil
}




func CheckContains(target string, rex string ) (bool, error) {
	// check if target contains rex 
	regexp1, err := regexp.Compile("*"+rex+"*")
	if err != nil {
		return false, err
	}

	return regexp1.MatchString(target), nil

}